      REAL*8 FUNCTION WTIME()
      IMPLICIT NONE
C
C     USE THE F90 INTRINSIC  SYSTEM_CLOCK  TO RETURN WALL TIME.
C
C     WILL FAIL IF THE COUNT IS EVER NEGATIVE, BUT THE STANDARD
C     SAYS THAT IT IS AWAYS NON-NEGATIVE IF A CLOCK EXISTS.
C     NOT THREAD-SAFE, UNLESS LCOUNT AND IOVER ARE THREADPRIVATE.
C
      REAL*8     ZERO,ONE
      PARAMETER (ZERO=0.0, ONE=1.0)
C
      INTEGER COUNT, MCOUNT, RATE
C
      REAL*8  OFFSEC, OFFSET, PERSEC
      INTEGER ICOUNT, IOVER,  LCOUNT, NCOUNT
      SAVE    OFFSEC, OFFSET, PERSEC
      SAVE    ICOUNT, IOVER,  LCOUNT, NCOUNT
C
      DATA IOVER, LCOUNT / -1, -1 /
C
      CALL SYSTEM_CLOCK(COUNT)
C
      IF     (COUNT.LT.LCOUNT) THEN
C
C        COUNT IS SUPPOSED TO BE NON-DECREASING EXCEPT WHEN IT WRAPS,
C        BUT SOME IMPLEMENTATIONS DON''T DO THIS.  SO IGNORE ANY
C        DECREASE OF LESS THAN ONE PERCENT OF THE RANGE.
C
         IF     (LCOUNT-COUNT.LT.NCOUNT) THEN
           COUNT  = LCOUNT
         ELSE
           IOVER  = IOVER + 1
           OFFSET = OFFSET + OFFSEC
         ENDIF
      ENDIF
      LCOUNT = COUNT
C
      IF     (IOVER.EQ.0) THEN
C
C       FIRST CYCLE, FOR ACCURACY WITH 64-BIT COUNTS.
C
         WTIME = (COUNT - ICOUNT) * PERSEC
      ELSEIF (IOVER.GT.0) THEN
C
C        ALL OTHER CYCLES.
C
         WTIME = COUNT * PERSEC + OFFSET
      ELSE
C
C        INITIALIZATION.
C
         CALL SYSTEM_CLOCK(ICOUNT, RATE, MCOUNT)
         NCOUNT =  MCOUNT/100
         PERSEC =  ONE/RATE
         OFFSEC =  MCOUNT * PERSEC
         OFFSET = -ICOUNT * PERSEC
         IOVER  =  0
         WTIME  =  ZERO
      ENDIF
      RETURN
C     END OF WTIME.
      END
